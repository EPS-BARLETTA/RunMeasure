<!-- mode.html ‚Äî RunMeasure (REMPLACEMENT COMPLET) -->
<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>RunMeasure ‚Ä¢ Mode</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 900px; margin: 0 auto; padding: 16px; }
    header, footer { text-align: center; margin: 8px 0; }
    .card { border:1px solid #ddd; border-radius:12px; padding:12px; background:#fff; margin-bottom:12px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; }
    .row > * { flex:1; min-width: 220px; }
    .btn { display:inline-block; padding:10px 14px; border-radius:10px; border:1px solid #ccc; background:#f5f5f5; font-weight:600; cursor:pointer; }
    .btn-primary { background:#eaf3ff; border-color:#bcd4ff; }
    .btn-danger { background:#ffecec; border-color:#ffc8c8; }
    .btn-success { background:#eaffea; border-color:#c8ffc8; }
    .stat { font-size: 1.3rem; font-weight: 700; }
    table { width:100%; border-collapse: collapse; }
    th, td { border:1px solid #ddd; padding:6px 8px; text-align:left; }
    th { background:#f7f7f7; }
    #qr-box { margin-top: 16px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1 id="mode-title">Mode</h1>
      <nav>
        <a href="options.html">‚Üê Choisir un autre mode</a> ¬∑
        <a href="index.html">Accueil</a> ¬∑
        <a href="aide.html">Aide</a>
      </nav>
    </header>

    <!-- Bloc param√®tres sp√©cifiques au mode -->
    <section id="params" class="card">
      <h2>Param√®tres</h2>
      <div class="row" id="distance-row" style="display:none">
        <div>
          <label for="distance-input">Distance (m)</label>
          <input id="distance-input" type="number" min="0" placeholder="ex : 400">
        </div>
      </div>
      <div class="row" id="timer-row" style="display:none">
        <div>
          <label for="time-input">Dur√©e (MM:SS)</label>
          <input id="time-input" type="text" placeholder="06:00">
        </div>
      </div>
      <p id="hint" style="margin:0; color:#555"></p>
    </section>

    <!-- Contr√¥les -->
    <section class="card">
      <h2>Contr√¥les</h2>
      <div class="row">
        <button id="start-btn" class="btn btn-success">‚ñ∂Ô∏è D√©marrer</button>
        <button id="split-btn" class="btn" style="display:none">üèÅ Temps interm√©diaire</button>
        <button id="stop-btn" class="btn btn-primary" disabled>‚è∏Ô∏è Stop</button>
        <button id="reset-btn" class="btn btn-danger" disabled>üîÑ Reset</button>
      </div>
    </section>

    <!-- R√©sultats -->
    <section class="card" id="results">
      <h2>R√©sultats</h2>
      <div class="row">
        <div>
          <div>Temps</div>
          <div id="time-result" class="stat">00:00</div>
        </div>
        <div id="distance-col" style="display:none">
          <div>Distance totale</div>
          <div id="distance-result" class="stat">‚Äî</div>
        </div>
        <div id="speed-col" style="display:none">
          <div>Vitesse estim√©e</div>
          <div id="speed-result" class="stat">‚Äî</div>
        </div>
      </div>

      <div id="splits-block" style="display:none; margin-top:12px;">
        <h3>Interm√©diaires</h3>
        <table id="splits-table">
          <thead><tr><th>#</th><th>Temps</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- Le QR sera inject√© ici par modes.js -->
    <div id="result"></div>

    <footer>
      RunMeasure - Equipe EPS Lyc√©e Vauban - LUXEMBOURG - JB
    </footer>
  </div>

  <!-- Librairie QR, puis modes.js (ordre important) -->
  <script defer src="qrcode.min.js"></script>
  <script defer src="modes.js"></script>

  <!-- Script local : logique des boutons & affichage par mode -->
  <script>
  (function() {
    const qs = new URLSearchParams(location.search);
    const mode = (qs.get('mode') || '').toLowerCase();

    // Elements
    const title = document.getElementById('mode-title');
    const hint = document.getElementById('hint');

    const rowDistance = document.getElementById('distance-row');
    const rowTimer = document.getElementById('timer-row');

    const distanceInput = document.getElementById('distance-input');
    const timeInput = document.getElementById('time-input');

    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const resetBtn = document.getElementById('reset-btn');
    const splitBtn = document.getElementById('split-btn');

    const timeResult = document.getElementById('time-result');
    const distanceCol = document.getElementById('distance-col');
    const distanceResult = document.getElementById('distance-result');
    const speedCol = document.getElementById('speed-col');
    const speedResult = document.getElementById('speed-result');

    const splitsBlock = document.getElementById('splits-block');
    const splitsTbody = document.querySelector('#splits-table tbody');

    // Horloge
    let t0 = 0, raf = 0, running = false;
    let countdown = false, targetMs = 0; // minuteur
    let elapsed = 0; // ms cumul√©s (pour stop/restart correct)
    let fixedDurationMs = 0; // demi_cooper/cooper
    let splits = [];

    function pad(n){ return String(n).padStart(2,'0'); }
    function msToClock(ms){
      const total = Math.max(0, Math.round(ms/1000));
      const h = Math.floor(total/3600);
      const m = Math.floor((total%3600)/60);
      const s = total%60;
      return h>0 ? `${h}:${pad(m)}:${pad(s)}` : `${m}:${pad(s)}`;
    }
    function parseTimeInput(v){
      // "MM:SS" ou "HH:MM:SS"
      if (!v) return 0;
      const p = v.split(':').map(x => Number(x));
      if (p.length === 2) { return (p[0]*60 + p[1]) * 1000; }
      if (p.length === 3) { return (p[0]*3600 + p[1]*60 + p[2]) * 1000; }
      return 0;
    }
    function readDistance(){
      const v = Number((distanceInput.value||'').replace(',', '.'));
      return Number.isFinite(v) && v>0 ? Math.round(v) : 0;
    }
    function computeSpeedKmh(dist_m, ms){
      if (!dist_m || !ms) return null;
      const v = (dist_m / (ms/1000)) * 3.6;
      return Math.round(v*100)/100;
    }

    function tick(){
      if (!running) return;
      const now = performance.now();
      const dt = now - t0;
      t0 = now;
      elapsed += dt;

      if (countdown) {
        const remain = Math.max(0, targetMs - elapsed);
        timeResult.textContent = msToClock(remain);
        if (remain <= 0) {
          stop();
        } else {
          raf = requestAnimationFrame(tick);
        }
      } else {
        timeResult.textContent = msToClock(elapsed);
        raf = requestAnimationFrame(tick);
      }

      // Vitesse live si chronos avec distance
      if ((mode === 'chrono_vitesse' || mode === 'minuteur_distance' || mode === 'demi_cooper' || mode === 'cooper')) {
        const d = readDistance();
        if (d) {
          const baseMs = countdown ? (targetMs - Math.max(0, targetMs - elapsed)) : elapsed;
          const v = computeSpeedKmh(d, baseMs);
          if (v) {
            speedResult.textContent = v + " km/h";
          }
        }
      }
    }

    function start(){
      if (running) return;
      running = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;
      resetBtn.disabled = false;
      t0 = performance.now();
      raf = requestAnimationFrame(tick);
    }
    function stop(){
      if (!running) return;
      running = false;
      stopBtn.disabled = true;
      startBtn.disabled = false;
      cancelAnimationFrame(raf);
      raf = 0;
    }
    function reset(){
      running = false;
      cancelAnimationFrame(raf);
      raf = 0;
      elapsed = 0;
      timeResult.textContent = "00:00";
      splits = [];
      splitsTbody.innerHTML = "";
      distanceResult.textContent = "‚Äî";
      speedResult.textContent = "‚Äî";
      stopBtn.disabled = true;
      resetBtn.disabled = true;
      startBtn.disabled = false;

      // Pour minuteur : recharger la cible
      if (mode === 'minuteur') {
        targetMs = parseTimeInput(timeInput.value || "06:00");
        timeResult.textContent = msToClock(targetMs);
      }
      if (mode === 'demi_cooper') {
        targetMs = fixedDurationMs = 6*60*1000;
        timeResult.textContent = msToClock(targetMs);
      }
      if (mode === 'cooper') {
        targetMs = fixedDurationMs = 12*60*1000;
        timeResult.textContent = msToClock(targetMs);
      }
    }

    function addSplit(){
      const clock = timeResult.textContent.trim();
      splits.push(clock);
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${splits.length}</td><td class="split">${clock}</td>`;
      splitsTbody.appendChild(tr);
    }

    function updateDistanceOutput(){
      const d = readDistance();
      if (d) {
        distanceResult.textContent = d + " m";
      } else {
        distanceResult.textContent = "‚Äî";
      }
    }

    // Config par mode
    switch (mode) {
      case 'chrono':
        title.textContent = 'Chrono';
        hint.textContent = 'D√©marre/Stop. Utilise Reset pour remettre √† z√©ro.';
        countdown = false;
        rowDistance.style.display = 'none';
        distanceCol.style.display = 'none';
        speedCol.style.display = 'none';
        splitBtn.style.display = 'none';
        break;

      case 'minuteur':
        title.textContent = 'Minuteur';
        hint.textContent = 'R√®gle la dur√©e (MM:SS), puis D√©marrer. Le minuteur s‚Äôarr√™te √† z√©ro.';
        rowTimer.style.display = 'block';
        countdown = true;
        targetMs = parseTimeInput(timeInput.value || "06:00");
        timeResult.textContent = msToClock(targetMs);
        splitBtn.style.display = 'none';
        break;

      case 'chrono_vitesse':
        title.textContent = 'Chrono avec calcul de vitesse';
        hint.textContent = 'Renseigne la distance totale (m). La vitesse est estim√©e en direct.';
        rowDistance.style.display = 'block';
        distanceCol.style.display = 'block';
        speedCol.style.display = 'block';
        splitBtn.style.display = 'none';
        distanceInput.addEventListener('input', updateDistanceOutput);
        break;

      case 'minuteur_distance':
        title.textContent = 'Minuteur avec distance';
        hint.textContent = 'Renseigne la distance (m) et la dur√©e (MM:SS). La vitesse est estim√©e.';
        rowDistance.style.display = 'block';
        rowTimer.style.display = 'block';
        distanceCol.style.display = 'block';
        speedCol.style.display = 'block';
        countdown = true;
        targetMs = parseTimeInput(timeInput.value || "06:00");
        timeResult.textContent = msToClock(targetMs);
        distanceInput.addEventListener('input', updateDistanceOutput);
        break;

      case 'intermediaire':
        title.textContent = 'Temps interm√©diaire';
        hint.textContent = 'Utilise D√©marrer, puis ‚ÄúTemps interm√©diaire‚Äù pour enregistrer les splits.';
        splitBtn.style.display = 'inline-block';
        splitsBlock.style.display = 'block';
        break;

      case 'demi_cooper':
        title.textContent = 'Demi-Cooper (6‚Ä≤)';
        hint.textContent = 'Distance libre (m). Minuteur fixe 6:00, ajoute la distance r√©alis√©e.';
        rowDistance.style.display = 'block';
        distanceCol.style.display = 'block';
        speedCol.style.display = 'block';
        countdown = true;
        fixedDurationMs = 6*60*1000;
        targetMs = fixedDurationMs;
        timeResult.textContent = msToClock(targetMs);
        distanceInput.addEventListener('input', updateDistanceOutput);
        break;

      case 'cooper':
        title.textContent = 'Cooper (12‚Ä≤)';
        hint.textContent = 'Distance libre (m). Minuteur fixe 12:00, ajoute la distance r√©alis√©e.';
        rowDistance.style.display = 'block';
        distanceCol.style.display = 'block';
        speedCol.style.display = 'block';
        countdown = true;
        fixedDurationMs = 12*60*1000;
        targetMs = fixedDurationMs;
        timeResult.textContent = msToClock(targetMs);
        distanceInput.addEventListener('input', updateDistanceOutput);
        break;

      default:
        title.textContent = 'Mode inconnu';
        hint.textContent = 'Reviens √† la page des options pour choisir un mode.';
        startBtn.disabled = true;
        stopBtn.disabled = true;
        resetBtn.disabled = true;
        return;
    }

    // Boutons
    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
    resetBtn.addEventListener('click', reset);
    splitBtn.addEventListener('click', addSplit);

    // Init distance affich√©e au chargement (si pr√©-remplie)
    updateDistanceOutput();
  })();
  </script>
</body>
</html>
